<!DOCTYPE html>
<html>
<head><title>Tile Performance Test</title></head>
<body>
<h1>Tile Loading Performance</h1>
<button onclick="testViewport()">Test Viewport Loading</button>
<pre id="output"></pre>
<script>
// Simulate the renderer's tile loading functions
function lon2tile(lon, zoom) {
  return Math.floor(((lon + 180) / 360) * Math.pow(2, zoom));
}

function lat2tile(lat, zoom) {
  return Math.floor(
    ((1 - Math.log(Math.tan((lat * Math.PI) / 180) + 1 / Math.cos((lat * Math.PI) / 180)) / Math.PI) / 2) *
      Math.pow(2, zoom)
  );
}

function getVisibleTiles(bounds, zoom) {
  const minX = lon2tile(bounds.minLon, zoom);
  const maxX = lon2tile(bounds.maxLon, zoom);
  const minY = lat2tile(bounds.maxLat, zoom);
  const maxY = lat2tile(bounds.minLat, zoom);

  const tiles = [];
  for (let x = minX; x <= maxX; x++) {
    for (let y = minY; y <= maxY; y++) {
      tiles.push({ z: zoom, x, y });
    }
  }
  return tiles;
}

async function testViewport() {
  const output = document.getElementById('output');
  let text = 'Testing viewport tile loading...\n\n';
  
  // Default Hamburg viewport (zoom 1.5 → should use Z8 tiles)
  const bounds = {
    minLon: 9.77,
    maxLon: 10.21,
    minLat: 53.415,
    maxLat: 53.685
  };
  
  // Test Z8 (far view)
  const tilesZ8 = getVisibleTiles(bounds, 8);
  text += `Zoom 8 (far view): ${tilesZ8.length} tiles needed\n`;
  tilesZ8.forEach(t => text += `  - ${t.z}/${t.x}/${t.y}\n`);
  
  // Load them
  const start = performance.now();
  let totalFeatures = 0;
  for (const tile of tilesZ8) {
    try {
      const resp = await fetch(`tiles/${tile.z}/${tile.x}/${tile.y}.json.gz`);
      if (resp.ok) {
        const compressed = await resp.arrayBuffer();
        const decompressed = new Response(
          new Response(compressed).body.pipeThrough(new DecompressionStream('gzip'))
        );
        const data = await decompressed.json();
        totalFeatures += data.features.length;
        text += `    ✓ Loaded ${data.features.length} features (${(compressed.byteLength/1024).toFixed(1)}KB)\n`;
      }
    } catch (e) {
      text += `    ✗ Error: ${e}\n`;
    }
  }
  const elapsed = (performance.now() - start).toFixed(2);
  
  text += `\nTotal: ${totalFeatures} features in ${elapsed}ms\n`;
  text += `Average: ${(elapsed / tilesZ8.length).toFixed(2)}ms per tile\n`;
  
  // Test a tighter viewport (medium zoom → Z11)
  const tightBounds = {
    minLon: 9.95,
    maxLon: 10.05,
    minLat: 53.52,
    maxLat: 53.58
  };
  const tilesZ11 = getVisibleTiles(tightBounds, 11);
  text += `\nZoom 11 (medium): ${tilesZ11.length} tiles for tighter viewport\n`;
  
  output.textContent = text;
}
</script>
</body>
</html>
